h1. General info

Written in C#.NET (.NET 4.0) using WPF in Visual Studio 2010. Use git (google for msysgit on Windows) to clone this repository. Command line:

bq. git clone git://github.com/mrbrdo/MidiSynth.git

Then open the solution (.sln file) in Visual Studio.

h1. How it works

The basic structure is comprised of an input source, and an output channel. The output channel's output is played through the output device (currently only soundcard output).

h2. Input sources (IAudioInputSource)

An input source must generate an output which is then routed into a channel (usually the output channel).

Some input sources (like those which play notes) will generate sub-channels (for each note being played) and then merge (in this case by summing the outputs of all the sub-channels) those to generate the output signal.

h3. Example: IS_ScalePlayer

<pre>
<code>
            CC_Info info = new CC_Info;
            info.SampleRate = 8000;
            info.BufferSize = 400;

            new IS_ScalePlayer(Info,
                (CC_Channel chan) =>
                {
                    List<IAudioChainMember> is_chain = new List<IAudioChainMember>();
                    is_chain.Add(new CM_Oscillator(chan, (float freq, int step, int sr) =>
                    {
                        double oi = 2 * Math.PI * freq * step / (double)sr;
                        return (float)(Math.Sin(oi));
                    }));
                    is_chain.Add(new CM_ChannelTerminator(chan));
                    chan.SetChain(is_chain);
                }, 500);
</code>
</pre>

The IS_ScalePlayer accepts a lambda function which will be used to set up the channels it uses for playing each note. This is important if we want to perform some processing on each seperate note being played (for example adding an envelope). In this case we add a sine wave oscillator and a terminator (read about terminators below).

h2. Channel

A channel is just a container class which contains one or more chain members (IAudioChainMember). When requesting output from a channel, it will pass its input into the first chain member, the output of that into the second chain member, etc. and return the output of the last chain member.

h2. Chain members (IAudioChainMember)

A chain member is simply a class which takes an input and generates an output. Some classes that are implemented as chain members: CM_Oscillator, CM_Normalizator, CM_ADSR_Envelope, CM_ChannelTerminator.

h2. Chain members and number of samples

A chain member's input is just the current input sample. If the chain member needs to access past samples or past outputs, it must create a buffer to store them.

h2. Channel terminators

A channel terminator is sometimes required as a consequence of a design decision.

Take for example the MIDI keyboard inuput source. When a key is pressed on the MIDI keyboard, the IS_MidiIn input source will create a new channel with the correct frequency as the input (which will pass into the oscillator usually). However, when the key is depressed, if we wish to have an envelope release or a reverb effect, the channel must not yet be destroyed. Therefore, the input source will only create channels but not destroy them. The input source will, however, set a property on the channel that the input has ended. It is then the task of a terminator chain member to close the channel (by setting its active property to false). If we want to close the channel immediately after a key was depressed, CM_ChannelTerminator can be used. Otherwise, some other chain member must be responsible for closing the channel. An example of such a chain member is the CM_ADSR_Envelope class, which closes the channel after the release time has passed.

h1. Basic modifications

For basic modifications open the ConfSetup.cs file and modify the Setup method which is responsible for setting up the input source and output channel.

h2. Example for a clarinet sound with an ADSR envelope
<pre>
<code>
        public static void SetupClarinetWithEnvelope(out IAudioInputSource inputSource, out CC_Channel outChannel)
        {
            inputSource = new IS_ScalePlayer(Info,
                (CC_Channel chan) =>
                {
                    List<IAudioChainMember> is_chain = new List<IAudioChainMember>();
                    is_chain.Add(new CM_Oscillator(chan, (float freq, int step, int sr) =>
                    {
                        double oi = 2 * Math.PI * freq * step / (double)sr;
                        return (float)(Math.Cos(oi) + 0.375 * Math.Cos(3 * oi) +
                            0.581 * Math.Cos(5 * oi) + 0.382 * Math.Cos(7 * oi) +
                            0.141 * Math.Cos(9 * oi) + 0.028 * Math.Cos(11 * oi) + 0.009 * Math.Cos(13 * oi));
                    }));
                    is_chain.Add(new CM_ADSR_Envelope(chan, new float[] { 0.3f, 0, 0.3f }, 1, CM_ADSR_Envelope.ADSRLinearFunction));
                    chan.SetChain(is_chain);
                }, 500);

            outChannel = new CC_Channel(Info);
            List<IAudioChainMember> chain = new List<IAudioChainMember>();

            chain.Add(new CM_Normalizator(outChannel));
            chain.Add(new CM_BufferVisualizer(outChannel, 800));

            outChannel.SetChain(chain);
            outChannel.Activate();
        }
</code>
</pre>